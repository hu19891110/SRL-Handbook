<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SRL - official handbook</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/handbook.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <h1>Sphere Research Labs - official handbook</h1>

      This document is the guide for users of our <em>online judge</em> based services including: 
      <ul>
        <li>Sphere Engine&trade;</li>
        <li>Sphere Contest&trade;</li>
      </ul>
      <p>First of all <em>it is not</em> comprehensive and exhaustive manual for vast area of technical issues of mentioned services. We focus on the essence of functionality namely the idea of processing source codes submitted into the system. As the user of one of our products you will be the creator of new programming problems. Let us introduce the convention of naming - the person who creates the problem is <em>the problem setter</em> or <em>the author</em> and the person who use the service and solves the problem is just <em>the user</em>. All presented information are independent of the type of our service thus we just call it <em>service</em>. Also note that the services are rather oriented to deal with console applications with standard input/output communication. The next section is a <em>dictionary</em> where we introduce simple definitions.</p>

      <h2>Dictionary</h2>

      <ul>
	      <li><strong>Sphere Engine&trade;</strong> ­ <span class="todo">TODO</span>Platforma do weryfikacji praktycznych umiejętności programistycznych. 
	      Posiada wbudowany zestaw kompilatorów oraz bazę zadań testowych. System pozwala na 
	      automatyczną ocenę nadsyłanych rozwiązań, które dostarczane są w postaci kodów 
	      źródłowych.</li>
	      <li><strong>Sphere Contest&trade;</strong> ­ <span class="todo">TODO</span>Platforma do weryfikacji praktycznych umiejętności programistycznych. 
	      Posiada wbudowany zestaw kompilatorów oraz bazę zadań testowych. System pozwala na 
	      automatyczną ocenę nadsyłanych rozwiązań, które dostarczane są w postaci kodów 
	      źródłowych.</li>
	      <li><strong>Problem</strong> ­ The challange task for service's users which is the basic element of the service and it contains:
	        <ul>
	          <li><strong>Description</strong> - text explanation of the problem nature along with input/output specification (see more <a href="#problem-specification">problem specification</a>)</li>
	          <li><strong>Test case</strong> - the set of input and output data along with a method of judging (see more <a href="#test-case">test case</a>)</li>
	          <li><strong>Master judge</strong> - the method of final scoring the execution of the submitted solution</li>
	        </ul>
	      </li>
	      <li><strong>Problem instance (input instance)</strong> - The set of data which determines all variables from the problem definition. For example number <em>10</em> is an instance for <em>the prime number</em> problem (i.e. for a given number <em>n</em> determine if <em>n</em> is a prime number).</li>
	      <li><strong>Test case</strong> ­ The set of data (usually pair of input file and correct output file) used for verification of the user's submission. It serves as a certificate of the correctness and also contains:
	        <ul>
	          <li><strong>time limit</strong> - the maximum time of the user's solution execution with the data from input file</li>
	          <li><strong>tast case judge</strong> - a program that analyses the output generated by user's solution (usually compares user's output with correct output) (see more <a href="#test-case-judge">test case judge</a>, <a href="#advance-test-case-judge">advance test case judge</a>)</li>
	        </ul>
	      </li>
	      <li><strong>Submission</strong> ­ The source code which is potentially the correct solution to the problem.</li>
	      <li><strong>Submission status</strong> - short information about the user's submission execution. It can be one of the following: <em>accepted</em>, <em>wrong answer</em>, <em>time limit exceeded</em>, <em>run time error</em>, <em>compile error</em> (see more <a href="submission-statuses">submission statuses</a>)</li>
	      <li><strong>User</strong> ­ The programmer (developer).</li>
	      <li><strong>Problem setter</strong> ­ User of the service with the permissions to create and manage problems.</li>
	      <li><strong>Manager</strong> ­  User of the service with the permissions to manage whole service's content.</li>
	      <li><strong>Administrator</strong> ­ User of the service with full set of permissions.</li>
      </ul>

      <h2>1. Introduction</h2>

      <p>To sketch the idea of automatic program correctness verification as simple as possible we first consider classical (manual) methods and after that we present automatic methods. We are going to point differences between these two approaches and indicate advantages of the automatic method.</p>

      <h3>Manual verification</h3>
		
			<p>The problem setter needs to try the code manually i.e. he needs to try it for some simple input data. In that situation even simple programs require at least small human readable interface. Let us consider the following toy example along with the <em>C</em> language solution:</p>

      <div class="problem_example">
        <div class="problem_name">Integer power</div>
        <div class="problem_description">Write the program which takes two numbers <em>a</em> and <em>b</em> and returns the value of <em>a<sup>b</sup></em>.</div>
        <div id="human-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #B00040">int</span> <span style="color: #0000FF">atob</span>(<span style="color: #B00040">int</span> a, <span style="color: #B00040">int</span> b)
{
  <span style="color: #B00040">int</span> i, result <span style="color: #666666">=</span> <span style="color: #666666">1</span>;
  <span style="color: #008000; font-weight: bold">for</span>(i<span style="color: #666666">=0</span>; i <span style="color: #666666">&lt;</span> b; i<span style="color: #666666">++</span>)
  {
    result <span style="color: #666666">*=</span> a;
  }
  <span style="color: #008000; font-weight: bold">return</span> result;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> a,b;
  printf(<span style="color: #BA2121">&quot;Give a: &quot;</span>);
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>a);
  printf(<span style="color: #BA2121">&quot;Give b: &quot;</span>);
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>b);
  printf(<span style="color: #BA2121">&quot;a to the power of b = %d&quot;</span>, atob(a,b));
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
        </div>
      </div>

      <p>After compiling and running that piece of code the problem setter is ready to use the program. Nevertheless, it is easily seen that manual verification requires autor's continuous preparation - for each input the autor must know the correct output. That's the rule for all problems he manages - the author is forced to remember how to verify the corectness of all his problems. Another issue is that he probably wants to be reliable thus he needs to handle with all boundary, clever and problematic input instances. Some interesting situations can be pointed even for that simple problem above. For example, does <em>a</em> to the power of <em>zero</em> give <em>1</em>?</p>

      <p>Another question is how to deal with time and memory complexity issues? Academic experience of members of our team yields that the automatic judge solutions save plenty of time and greatly improve the quality of verification.</p>

      <h3>Automatic verification</h3>

      <p>Moving on to the online judging we will present you how we need to change approach. Now whole the process of the compiling, running and testing is going to be conducted by the machine thus we need to clearly specify how the program should communicate - that part we call <em>input / output specification</em>. Suppose we want to prepare the <em>Integer power</em> problem to automatic judging and suppose the presented source code fulfills desired input/output specification (usually the direction is opposite - first we specify the input and output structure then we implement the solution). It means we need, along with the problem definition, give the information that program should expect two integer numbers on the input and needs to print the information "Print a: Print b: a to the power of b = a<sup>b</sup>". Clearly the output specification is highly unnatural.</p>

      <p>As you can see we don't need to have any human readable interface at all. In fact, it is rather obstruction which can even lead to reject correct solutions due to some complicated or nonintuitive input or output requirements. How simple can the previous <em>Integer power</em> problem could be if we drop all the input / output formating? We don't want to have any "Give me the value" statements to obtain the input and "Result is" statements in the output thus it would be enough to stay with minimal source code:</p>

        <div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #B00040">int</span> <span style="color: #0000FF">atob</span>(<span style="color: #B00040">int</span> a, <span style="color: #B00040">int</span> b)
{
  <span style="color: #B00040">int</span> i, result <span style="color: #666666">=</span> <span style="color: #666666">1</span>;
  <span style="color: #008000; font-weight: bold">for</span>(i<span style="color: #666666">=0</span>; i <span style="color: #666666">&lt;</span> b; i<span style="color: #666666">++</span>)
  {
    result <span style="color: #666666">*=</span> a;
  }
  <span style="color: #008000; font-weight: bold">return</span> result;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> a,b;
  scanf(<span style="color: #BA2121">&quot;%d %d&quot;</span>, <span style="color: #666666">&amp;</span>a, <span style="color: #666666">&amp;</span>b);
  printf(<span style="color: #BA2121">&quot;%d&quot;</span>, atob(a,b));
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>

        </div>

        <p>We highly recommend you to put emphasis on input / output specification when you will present your instance of the service to your own users. Base on our own experience with online judge beginners users we know that it's most dangerous when you deal with developers who have some basic knowledge already and along with that probably some habits. We present extended description of input and output specification in the next section.</p>

        <p>Finally, let us take a look at the simplified submission flow diagram:</p>
        
        <div id="simple-submission-flow-diagram" class="centered_image_container"><img width="600" alt="Simple submission flow diagram" src="./fig/simple_diagram.png" /></div>

        <p>In this diagram we can see how user's source code go through the system. Firstly it is compiled by a proper compiler (according to the selected programming language) which produces executable file<sup>1</sup>. In the next step created executable is fed with model input data and we obtain the user's output file. The final step is the procedure of comparing the user's output file with the model output file, we call it <em>judging</em>. The judge returns the status of the submission. Note that the diagram is a simplified sketch of the idea and we will extend both the picture and the explanation.</p>

        <p class="footnote">1. In case of script languages we use proper interpreter to run the code.</p>

      <h2 id="problems">2. Problems and submissions</h2>

      <p>In this section we are going to give you insight into submission flow and online judge problem construction. From the previous section we know basics of the concept of the online judging. To better understand and make it possible to create own problems we will describe components of the problem:</p>

      <ul id="problem-components">
        <li><strong>Description</strong>
          <ul>
            <li>The task</li>
            <li>Input / output specification</li>
            <li>Input / output examples</li>
          </ul>
        </li>
        <li><strong>Test case(s)</strong> (possibly many)
          <ul>
            <li>Input file, Output file</li>
            <li>Time limit</li>
            <li>Judge</li>
          </ul>
        </li>
        <li><strong>Master judge</strong></li>
      </ul>

      <p id="submission-flow">Before we begin the analysys of the individual components let us take a loot at the complete diagram of submission flow to embed the listed components in overall view.</p>

      <div id="submission-flow-diagram" class="centered_image_container"><img width="700" alt="Full submission flow diagram" src="./fig/full_diagram.png" /></div>

      <p>The diagram is the extension of the one from the previous section. The main difference is the appearance of the <em>master judge</em> component. Since we have introduced possibility of many test cases (input, output and judge) thus we need the summary component to combine the results from test case judges - we call that summary component <em>master judge</em>. The other new elements of the diagram was mentally present before but we purposely omited them to keep the previous view as simple as possible. Now we can explain that every submission needs to have precised <em>programming language</em> to choose proper compiler or interpreter. The problem description is the crucial part for users to make it possible to solve the problem.</p>

      <p>Now let us recall the <em>Integer Power</em> problem since we are going to use it as a demonstration example. The task described in the problem is to compute the value of <em>a<sup>b</sup></em> for given integers <em>a</em> and <em>b</em>.

      <h3>Description</h3>
        <p>User must be able to understand the problem to solve it successfully. Description contains complete information needed to solve the problem thus it is the most important feature from the user's point of view.</p>

        <h4>The task</h4>
        <p>The formal text that describes the specificity of the problem usually in mathematical manner. To achieve good quality of the description it is a good habit to graphically illustrate the problem. It is also desirable to support a dry theory with simple examples.</p>

        <p>According to the <em>Integer Power</em> problem we could write the taks as follows:
          <div class="example-box"><p>Write the program which takes two numbers <em>a</em> and <em>b</em> and returns the value of <em>a<sup>b</sup></em>. For example for <em>a = 3</em> and <em>b = 4</em> the result is <em>3<sup>4</sup> = 81</em></p></div>
        </p>

        <h4>Input / output specification</h4>
        <p>The previous part was formal from the mathematical perspective but not syntactically. Automatic judging is only possible when we can make an assumption on the problems's input and output behaviour. The interior of the user's program is a black box for us right now. We specify what is the input file structure to make it possible for users to implement proper input reading. The specification of input file should be an information that user can rely on.</p>

        <p>On the other hand we expect that user produces output file with a predictable structure. Formal specification of the output file is an information that we are going to rely on to verify the correctness of the submission.</p>

        <p>Referring to the <em>Integer Power</em> problem let us recall <a href="#judge-source-code">possible solution</a> of the problem. We didn't specify any formal input or output syntax in the previous section. First attempt was the solution with the human readable interface and after that we modified the code to achieve a raw version. We can use that source code as a base for following formal specification:
          <div class="example-box">
            <p>
              <strong>Input:</strong> In the only line of the input there will be two integer numbers <em>1 ≤ a ≤ 8</em> and <em>0 ≤ b ≤ 10</em> separated by a single space character.</p>
            <p>
              <strong>Output:</strong> Program should write a single number which is a value of <em>a<sup>b</sup></em>.
            </p>
          </div>
        </p>

        <h4>Input / output examples</h4>
        <p>In the task subsection we mentioned that it is a good habit to ilustrate the problem with the examples. The examples here are dedicated to ilustrate the input and output files structure. In the best case scenario they cover every distinct configuration of parameters (up to numbers, letters etc.) which is important for more complex problems.</p>

        <p>Referring to the <em>Integer Power</em> problem we present how we could compose the examples:
          <div class="example-box">
            <p>
            <strong>Example 1:</strong><br />
            &nbsp;&nbsp;<strong>Input:</strong><br />
            &nbsp;&nbsp;3 4<br />
            &nbsp;&nbsp;<strong>Output:</strong><br />
            &nbsp;&nbsp;81<br />
            </p>
            <p>
            <strong>Example 2:</strong><br />
            &nbsp;&nbsp;<strong>Input:</strong><br />
            &nbsp;&nbsp;7 0<br />
            &nbsp;&nbsp;<strong>Output:</strong><br />
            &nbsp;&nbsp;1<br />
            </p>
          </div>
        </p>
          
      <h3>Test case(s)</h3>
        <p>Just as the description was for users only so the test cases are for the machine checker. This is the essence of the automatic judging idea. The vast majority of the usages implements the following schema: there is a model input paired to a model output along with the program which can compare that model output with the user's output to decide whether user's answer is good or not.</p>
 
        <h4>Input and output files</h4>
        <p>Input file contains the problem instance and it must be consistent with the input specification. The output file should contain corresponding correct answers formatted in accordance to the output specification.

         of the correct program should be contained in the output file. It is not necessery to write the solution to the program to create the output file - it can be obtained in any manner.</p>

        <p>According to the <em>Integer Power</em> problem we present how we could prepare following test cases:
          <div class="example-box">
            <p>
            <strong>Test case 1:</strong><br />
            &nbsp;&nbsp;<strong>Input file:</strong><br />
            &nbsp;&nbsp;3 4<br />
            &nbsp;&nbsp;<strong>Output file:</strong><br />
            &nbsp;&nbsp;81<br />
            </p>
            <p>
            <strong>Test case 2:</strong><br />
            &nbsp;&nbsp;<strong>Input file:</strong><br />
            &nbsp;&nbsp;7 0<br />
            &nbsp;&nbsp;<strong>Output file:</strong><br />
            &nbsp;&nbsp;1<br />
            </p>
          </div>
        </p>

        <p><strong>Remark.</strong> It is recomended to construct the problems that are able to repeat the desired procedure as many times as we want to make it possible to test the user's submission with one test case. There are many reasons for that approach and for further information please visit <a href="#good-test-cases-design">good test cases design</a> appendix.</p>

        <h4>Time limit</h4>
        <p>We have already pointed that one of the features of online judging is the possiblity of estimating the time complexity. To achieve that the author of the problem has to adjust the timeout for program execution. Consider the case when the author knows two different algorithms for a problem, say <em>A</em> and <em>B</em>. Let us assume that the algorithm <em>A</em> is noticeably faster than the algorithm <em>B</em>. It is not very easy and obvious how to preper test cases to distinguish between these two algorithms. However, assuming that we have input data which is processed in the time <em>t<sub>A</sub></em> for the algorithm <em>A</em> which is much faster than execution time <em>t<sub>B</sub></em> for the algorithm <em>B</em> we can simply set the time limit somewhere between those values.</p>

        <p>With the timeout <em>t<sub>A</sub> ≤ t<sub>0</sub> ≤ t<sub>B</sub></em> we can assume that <em>A</em>-like algorithms will pass the test case and <em>B</em>-like algorithms will fail it due to exceeding the time limit.</p>
        
        <p><strong>Remark.</strong> Note that the presented approach highly depends on the machine thus you need to adjust your time limit to the computing cluster rather then your local machine.</p>

        <p>Our toy example problem is much too simple in assumptions to allow us to present example of time limits that distinguish different algorithms thus we put default time limit of <em>1s</em>. In the next section we present more complex example where we further discuss the time limit which can help to estimate the algorithm quality.</p>

        <h4>Judge</h4>
        <p>The judge is a program which process user's output file after execution. Its task is to establish if the submission passed the test case and potentially also returns <em>the score</em>. When the user's program pass the test case the returned status is <em>"accepted"</em>.</p>

        <p>Usually the judge implementation is reduced to compare the model output file with the user's output file. We support problem setters with default judges:
        <ul>
          <li><strong>Strict</strong> - it requires output files to be identical</li> 
          <li><strong>Ignoring differences in whitespaces</strong> - similar to the previous one but it ignores all extra whitespaces</li>
          <li><strong>Ignoring floating point errors up to a specific position</strong> - it allows the floating point numbers to be inaccurate i.e. we can accept the errors up to for example <em>0.001</em></li>
        </ul>
        <strong>Remark.</strong> The <em>Ignoring differences in whitespaces</em> judge is one of the most popular default choice. It is more liberal for output formating errors which in fact doesn't affect on the solution semantic correctness. Similarly <em>Ignoring floating point errors up to a specific position</em> judge is popular choice for problems where result numbers are not integers.
        </p>

        <p>We have mentioned that the judge can also return <em>the score</em>. More information will be presented in the section <a href="#advanced-judges">advanced test case judges</a>, for now you can assume that the score is the test case execution time.</p>

        <p>It is possible to create custom test case judges. The author can implement any kind of verification having full access to the input file, base input file, user's output file and even user's source code. For more information visit the section <a href="#advanced-judges">advanced test case judges</a>.</p>

        <p>For the <em>Integer Power</em> problem we decide to use default <em>Ignoring differences in whitespaces</em> judge for each test case thus we allow the user to generate extra whitespaces before and after the resulting number <em>a<sup>b</sup></em>. For example when user's solution prints <em>"&nbsp;&nbsp;&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;"</em> as a result for <em>"3 4"</em> problem instance it is still correct answer.</p>

      <h3>Master judge</h3>
      <p>We have discussed the individual test cases for the problem and established that each of them returns information, i.e. status and the score. The master judge is the component which combines all incoming results obtained from test cases to produce the final result which is the status and the score. You can look again at the <a href="#submission-flow-diagram">submission flow diagram</a> for better understanding.</p>

      <p>There are predefined master judges proper for most situations:
      <ul>
        <li><strong>Generic masterjudge</strong> - it gathers information from test case judges and requires each of them to achieve <em>"accepted"</em> as the result to establish final result as the <em>"accepted"</em>. When any test case ends with error the final answer is inherited from the first failed test case. For example when the problem has five test cases and the second and the fourth ones failed, the final result is inherited from the second test case. Generic masterjudge combines the execution times of all testcases and yields the sum as the final score.</li>
        <li><strong>Score is % of correctly solved sets</strong> - it is a more liberal masterjudge which allows to accept incomplete solution with the score which is the percentage of correctly solved test cases. For example when the problem has five test cases and again the second and the fourth ones failed but the rest was passed, the final score is equal to <em>60%</em>. The advantage is that the user gets more information about the correctness level of its solution.</li>
      </ul>
      </p>

      <p>When you need to use more complex master judge it is possible to create the new one or modify the existing ones. You have access to the source code of default master judges and they can be used as a base for your modifications. Further information about designing master judges you can find in the section <a href="advanced-master-judges">Advanced master judges</a></p>

      <p>The last missing part for the example we successively improve is the choice of master judge. We created two test cases and there is no need to implement the specific own master judge thus we select default one. When we need to distinguish the solutions as better or worst (but both correct) we should rather choose <em>Score is % of correctly solved sets</em> but in our situation each test case is a pure verification of correctness (i.e. no performance aspects tested) thus we select <em>Generic masterjudge</em> to force the user's solution to pass all test cases.</p>

      <h4>Complete toy example specification</h4>
      We have discussed all components of the problem specification therefore we are able to present whole problem setting:

          <div class="example-box">
            <h3 align="center">The Integer Power</h3>
            <p>
              <ul>
                <li><h4>Description</h4>
                  <p>Write the program which takes two numbers <em>a</em> and <em>b</em> and returns the value of <em>a<sup>b</sup></em>. For example for <em>a = 3</em> and <em>b = 4</em> the result is <em>3<sup>4</sup> = 81</em></p>
                  <p>
                    <strong>Input / output specification:</strong>
                    <div class="left-indent">
                      <p>
                        <strong>Input:</strong> In the only line of the input there will be two integer numbers <em>1 ≤ a ≤ 8</em> and <em>0 ≤ b ≤ 10</em> separated by a single space character.</p>
                      <p>
                        <strong>Output:</strong> Program should write a single number which is a value of <em>a<sup>b</sup></em>.</strong>
                      </p>
                    </div>
                  </p>
                  <p>
              <strong>Examples:</strong>
              <div class="left-indent">
                    <p>
                    <strong>Example 1:</strong><br />
                    &nbsp;&nbsp;<strong>Input:</strong><br />
                    &nbsp;&nbsp;3 4<br />
                    &nbsp;&nbsp;<strong>Output:</strong><br />
                    &nbsp;&nbsp;81<br />
                    </p>
                    <p>
                    <strong>Example 2:</strong><br />
                    &nbsp;&nbsp;<strong>Input:</strong><br />
                    &nbsp;&nbsp;7 0<br />
                    &nbsp;&nbsp;<strong>Output:</strong><br />
                    &nbsp;&nbsp;1<br />
                    </p>
                    </div>
                  </p>
                </li>
                <li><h4>Test cases</h4>
                  <div class="left-indent">
                  <p>
                    <p><strong>Test case 1:</strong></p>
                    <p>
                      &nbsp;&nbsp;<strong>Input file:</strong><br />
                      &nbsp;&nbsp;3 4<br />
                      &nbsp;&nbsp;<strong>Output file:</strong><br />
                      &nbsp;&nbsp;81<br />
                      </p>
                      <p><strong>Judge</strong> - Ignoring differences in whitespaces</p>
                      <p><strong>Time limit</strong> - 1s</p>
                  </p>
                  <p>
                    <p><strong>Test case 2:</strong></p>
                    <p>
                      &nbsp;&nbsp;<strong>Input file:</strong><br />
                      &nbsp;&nbsp;7 0<br />
                      &nbsp;&nbsp;<strong>Output file:</strong><br />
                      &nbsp;&nbsp;1<br />
                      </p>
                      <p><strong>Judge</strong> - Ignoring differences in whitespaces</p>
                      <p><strong>Time limit</strong> - 1s</p>
                  </p>
                </div>
                </li>
                <li><h4>Master judge</h4>
                  <div class="left-indent">Generic master judge</div>
                </li>
              </ul>
          </div>

      <h3 id="submission-statuses">Submission status</h3>
      Ultimately, for a full understanding of the diagram let as briefly comment possible statuses which can be assigned to the submission.
      <ul>
        <li><strong>Accepted (AC)</strong> - the submission is a correct solution to the problem.</li>
        <li><strong>Wrong answer (WA)</strong> - the submission is incorrect solution. It depends on master judge implementation.</li>
        <li><strong>Time limit exceeded (TLE)</strong> - the submission execution took to long. Again it depends on master judge implementation.</li>
        <li><strong>Runtime error (RE)</strong> - the error occurred during program execution.</li>
        <li><strong>Compilation error (CE)</strong> - the error occurred during compilation or syntax validation in interpreter.</li>
        <li><strong>Internal error (IE)</strong> - the error occurred on the serivice side. One of the possible reasons can be poorly designed test case judge or master judge.</li>
      </ul>

      More information along with examples of problems and source codes can be found in appendix <a href="more-about-statuses">statuses</a>.

      <h2 id="example-problem">3. Example</h2>
        <p>In this section we present more complicated example with full details to give you better overall look at abilities of our services. It is still an elementary example but it will tell you much more about the specific of online judging.</p>

        <p>The problem is to count the sum of numbers from <em>1</em> to given <em>n</em> i.e. <em>1 + 2 + 3 + ... + n</em>, we call it the <em>Initital sum</em> problem. We are going to preper it to handle with multiple input instances in a single test case by proper input / output specification design. Look at the following problem description:</p>

        <div class="example-box">
          <p>For a positive integer <em>n</em> calculate the value of the sum of all positive integers that are not greater than <em>n</em> i.e. <em>1 + 2 + 3 + ... + n</em>. For example when <em>n = 5</em> then the correct answer is <em>15</em>.</p>
          <p>
            <strong>Input:</strong> In the first line there will be the number <em>1 ≤ t ≤ 10000000</em> which is the number of instances for your problem. In each of the next <em>t</em> lines there will be one number <em>n</em> for which you should calculate the described initial sum.
          </p>
          <p>
            <strong>Output:</strong> For each <em>n</em> print the calculated initial sum. Separate answers with new line character.
          </p>

            <p>
            <strong>Example 1:</strong><br />
            &nbsp;&nbsp;<strong>Input:</strong><br />
            &nbsp;&nbsp;4<br />
            &nbsp;&nbsp;1<br />
            &nbsp;&nbsp;2<br />
            &nbsp;&nbsp;3<br />
            &nbsp;&nbsp;4<br />
            &nbsp;&nbsp;<strong>Output:</strong><br />
            &nbsp;&nbsp;1<br />
            &nbsp;&nbsp;3<br />
            &nbsp;&nbsp;6<br />
            &nbsp;&nbsp;10<br />
            </p>
            <p>
            <strong>Example 2:</strong><br />
            &nbsp;&nbsp;<strong>Input:</strong><br />
            &nbsp;&nbsp;2<br />
            &nbsp;&nbsp;10<br />
            &nbsp;&nbsp;11<br />
            &nbsp;&nbsp;<strong>Output:</strong><br />
            &nbsp;&nbsp;55<br />
            &nbsp;&nbsp;66<br />
            </p>
        </div>

        <p>Note that the input specification allows us to construct rich test cases which are able to distinguis between faster and slower solutions.</p>

        <p>Referring to the solution take into account that the possible input data can be too big for the standard <em>int</em> type thus we will use the <em>long long</em> type. Before we set test cases let us present two distinct solutions to the problem:</p>

        <div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #B00040">int</span> i;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=1</span>; i <span style="color: #666666">&lt;=</span> n; i<span style="color: #666666">++</span>)
  {
    sum <span style="color: #666666">+=</span> i;
  }
  <span style="color: #008000; font-weight: bold">return</span> sum;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
      </div>

      <p>The first solution directly refers to the definition of the problem i.e. the function <em>initsum</em> iterates from <em>1</em> to <em>n</em> to calculate desired value. The calculation requires <em>n</em> operations of addition to obtain the result.</p>

      <p>It is basic school knowledge that there exists the compact formula for that problem and we use it in the second implementation:</p>


      <div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #008000; font-weight: bold">return</span> n<span style="color: #666666">*</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
      </div>

      <p>Both programs are correct answer to the problem but if we want to distinguish the algorithms we can design test cases that only the second solution can pass. As we mentioned before it highly depends on the computational power of the machine. We present test cases that are valid for the computer of this text's author. Our suggestion is to design one test case which is easy to pass for both algorithms to give information that the solution is correct and the second test case that is possible to pass only for the second algorithm. It can give an information to the user, that his solution is correct but too slow. The user submitting solution similar to the first one will get information about test cases and will be able to see that his program passes first test case and exceed time limit in the second test case.</p>

      <p>We cannot put all input and output data here because of its size thus we write it in shortened manner:</p>

      <div class="example-box">
        <p>
        <strong>Test case 1:</strong><br />
        &nbsp;&nbsp;<strong>Input file:</strong><br />
        &nbsp;&nbsp;1000<br />
        &nbsp;&nbsp;1<br />
        &nbsp;&nbsp;2<br />
        &nbsp;&nbsp;...<br />
        &nbsp;&nbsp;1000<br />
        &nbsp;&nbsp;1000000<br />
        &nbsp;&nbsp;<strong>Output file:</strong><br />
        &nbsp;&nbsp;1<br />
        &nbsp;&nbsp;3<br />
        &nbsp;&nbsp;...<br />
        &nbsp;&nbsp;500500<br />
        &nbsp;&nbsp;500000500000<br />
        </p>
        <p>
        <strong>Test case 2:</strong><br />
        &nbsp;&nbsp;<strong>Input file:</strong><br />
        &nbsp;&nbsp;1000000<br />
        &nbsp;&nbsp;1<br />
        &nbsp;&nbsp;2<br />
        &nbsp;&nbsp;...<br />
        &nbsp;&nbsp;1000000<br />
        &nbsp;&nbsp;<strong>Output file:</strong><br />
        &nbsp;&nbsp;1<br />
        &nbsp;&nbsp;3<br />
        &nbsp;&nbsp;...<br />
        &nbsp;&nbsp;500000500000<br />
        </p>
      </div>

      <p>Computational power of current machines is enough to finish first test case instantly. Both presented algorithms finished computations with time below <em>0.01s</em>. However it is a good test case for a corectness verification only. First <em>1000</em> positive integers give us the assurance that solution is mathematically correct. We have also added single test with big number i.e. <em>n = 1000000</em> to make sure that user's solution bases on <em>long long</em> type. On the other hand the second test case is rich enough to make the first algorithm to exceed even <em>5s</em> time limit. The second algorithm works fast enough to pass that test case in time below <em>0.1s</em>. We have huge gap between <em>0.1s</em> and <em>5s</em> thus we can easily choose safe value as our time limit, for example again <em>1s</em>.</p>

      <p>We still haven't chosen judges for test cases and master judge for the problem. We don't have floating point numbers in our output file specification thus we rather decide to choose <em>Ignoring differences in whitespaces</em> judge for both test cases. It leaves users with possiblity of small formating errors without risk of unwanted rejections of theirs solutions. For example it is possible to replace new line characters with spaces in output formatting and still pass the test case.</p>

      <p>We assume that we want to accept every correct solution but distinguish the better ones and give them a better score. The <em>Score is % of correctly solved sets</em> master judge is perfect for that purpose. Submitting the first solution achieves the result of <em>50%</em> while the second solution passes both test cases and its result is <em>100%</em>.</p>

      <p><strong>Remark.</strong> Presented scoring method assumed both tests as equally worth <em>50%</em> each. To achieve different distribution of scores you need to modify the master judge and pick the scoring of test cases arbitrary. We present the example in the section <a href="advanced-master-judges">advanced master judges</a>.</p>

      <p>To sum up we present full problem specification:</p>

          <div class="example-box">
            <h3 align="center">The Initial Sum</h3>
            <p>
              <ul>
                <li><h4>Description</h4>
                  <p>For a positive integer <em>n</em> calculate the value of the sum of all positive integers that are not greater than <em>n</em> i.e. <em>1 + 2 + 3 + ... + n</em>. For example when <em>n = 5</em> then the correct answer is <em>15</em>.</p>
                  <p>
                    <strong>Input / output specification:</strong>
                    <div class="left-indent">
                      <p>
                        <strong>Input:</strong> In the first line there will be the number <em>1 ≤ t ≤ 10000000</em> which is the number of instances for your problem. In each of the next <em>t</em> lines there will be one number <em>n</em> for which you should calculate the described initial sum.
                      </p>
                      <p>
                        <strong>Output:</strong> For each <em>n</em> print the calculated initial sum. Separate answers with new line character.
                      </p>
                    </div>
                  </p>
                  <p>
              <strong>Examples:</strong>
                  <div class="left-indent">
                      <p>
                      <strong>Example 1:</strong><br />
                      &nbsp;&nbsp;<strong>Input:</strong><br />
                      &nbsp;&nbsp;4<br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;2<br />
                      &nbsp;&nbsp;3<br />
                      &nbsp;&nbsp;4<br />
                      &nbsp;&nbsp;<strong>Output:</strong><br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;3<br />
                      &nbsp;&nbsp;6<br />
                      &nbsp;&nbsp;10<br />
                      </p>
                      <p>
                      <strong>Example 2:</strong><br />
                      &nbsp;&nbsp;<strong>Input:</strong><br />
                      &nbsp;&nbsp;2<br />
                      &nbsp;&nbsp;10<br />
                      &nbsp;&nbsp;11<br />
                      &nbsp;&nbsp;<strong>Output:</strong><br />
                      &nbsp;&nbsp;55<br />
                      &nbsp;&nbsp;66<br />
                      </p>
                    </div>
                  </p>
                </li>
                <li><h4>Test cases</h4>
                  <div class="left-indent">
                  <p>
                    <p><strong>Test case 1:</strong></p>
                    <p>
                      &nbsp;&nbsp;<strong>Input file:</strong><br />
                      &nbsp;&nbsp;1000<br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;2<br />
                      &nbsp;&nbsp;...<br />
                      &nbsp;&nbsp;1000<br />
                      &nbsp;&nbsp;1000000<br />
                      &nbsp;&nbsp;<strong>Output file:</strong><br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;3<br />
                      &nbsp;&nbsp;...<br />
                      &nbsp;&nbsp;500500<br />
                      &nbsp;&nbsp;500000500000<br />
                      </p>
                      <p><strong>Judge</strong> - Ignoring differences in whitespaces</p>
                      <p><strong>Time limit</strong> - 1s</p>
                  </p>
                  <p>
                    <p><strong>Test case 2:</strong></p>
                    <p>
                      &nbsp;&nbsp;<strong>Input file:</strong><br />
                      &nbsp;&nbsp;1000000<br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;2<br />
                      &nbsp;&nbsp;...<br />
                      &nbsp;&nbsp;1000000<br />
                      &nbsp;&nbsp;<strong>Output file:</strong><br />
                      &nbsp;&nbsp;1<br />
                      &nbsp;&nbsp;3<br />
                      &nbsp;&nbsp;...<br />
                      &nbsp;&nbsp;500000500000<br />
                      </p>
                      <p><strong>Judge</strong> - Ignoring differences in whitespaces</p>
                      <p><strong>Time limit</strong> - 1s</p>
                  </p>
                </div>
                </li>
                <li><h4>Master judge</h4>
                  <div class="left-indent">Score is % of correctly solved sets</div>
                </li>
              </ul>
          </div>


			<h2 id="good-test-cases-design">4. Good test cases design</h2>
				It is common misunderstanding which leads to bad test cases design. The number of test cases assigned to the problem is limited to <em>64</em>. The individual test case is not intended to test only one problem instance, we recommend you to redesign your input / output specification to handle with multiple problem instances in one test case. Consider the following very elementary problem as an example:

				<div class="example-box">
					For given integer numbers <em>a</em> and <em>b</em> calculate the sum <em>a + b</em>.
				</div>

				We could design the input / output specification to calculate the sum only for two numbers:

				<div class="example-box">
				  <p>
            <strong>Input:</strong> In the only line of the input there will be two integer numbers <em>a</em> and <em>b</em> separated by a single space character.</p>
          <p>
            <strong>Output:</strong> Program should write a single number which is the value of <em>a + b</em>.
          </p>
				</div>

				<p>It is correct but it is highly not recommended. First of all even <em>64</em> test cases cover a small part of the possible problem instances. Secondly, the execution of each test case is time consuming (about <em>2s</em> additional time for each test case).</p>

				<p>We recommend to redesign the input / output specification in following manner:</p>

				<div class="example-box">
          <p>
            <strong>Input:</strong> In the first line there will be the number <em>t</em> which is the number of instances for the problem. In each of the next <em>t</em> lines there will be the pair of two numbers <em>a</em> and <em>b</em> for which you should calculate the value of <em>a + b</em>.
          </p>
          <p>
            <strong>Output:</strong> For each <em>a,b</em> pair print the calculated sum. Separate answers with new line character.
          </p>
				</div>

				<p>As you can see it is possible to pack a large number of problem instance into single test case.</p>				

				<p>Note that multiple test cases should rather be used to test different aspect of the problem.</p>

      <h2 id="build-in-features">5. Build-in judges and master judges</h2>
        <p>We have mentioned that the problem setter can choose from default test cases judges and master judges. In practice it is usually enough.</p>

        <h3>Test case judes</h3>

        <p>There are five default test case judges:
          <ul>
            <li><strong>Strict</strong> - it requires output files to be identical</li>
            <li><strong>Ignoring differences in whitespaces</strong> - similar to the previous one but it ignores all extra whitespaces. It is the standard judge for all problems with exactly one correct solution (in particular for binary problems).
            <div class="example-box">
              <p>For example consider the problem of prime factorisation of the number (i.e. for a number <em>n</em> find the prime factors <em>p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>k</sub></em> that <em>n = p<sub>1</sub>&middot;p<sub>2</sub>&middot;...&middot;p<sub>k</sub></em>). It is known that the prime factorisation of the number is unique up to the order of prime factors so if we require in output specification to write sorted list of factors there is only one good answer to the problem.</p>
            </div>
            </li>
            <li><strong>Ignoring floating point errors up to <em>10<sup>-2</sup></em></strong> - it allows the floating point numbers to be inaccurate i.e. we can accept the errors up to <em>0.01</em>. It is good choice for problems when the result is an approximation which don't require good precision.

	            <div class="example-box">
	            	<p>For example consider the problem of the triangle area, i.e. for given integer side lenghts <em>a,b,c</em> calculate the area of the triangle. In general the result is not an integer and accuracy is not crucial.</p>
	            </div>

            </li>
            <li><strong>Ignoring floating point errors up to <em>10<sup>-6</sup></em></strong> - it allows the floating point numbers to be inaccurate i.e. we can accept the errors up to <em>0.000001</em>. When you need a good precision it is obviously better choice than the previous judge.

							<div class="example-box">
	            	<p>For example consider the problem of the value of the sine function. The range of the sine function is <em>[-1,1]</em> thus the precision is important.</p>
	            </div>

            </li>
            <li><strong>Score is source length</strong> - it is the modification of the <em>Ignoring differences in whitespaces</em> judge i.e. it verifies the correctness of the solution in the same manner but in addition it returns the score which is the length of the source code. The judge is designed for challange type problems where the objective is to solve the problem with the shortest source code.

							<div class="example-box">
	            	<p>For example consider the problem of determining first <em>n</em> numbers in decimal expansion of the number &pi; for given <em>n</em>. The challange is to solve that problem with the shortest possible source code.</p>
	            </div>

            </li>
          </ul>
        </p>

        <h3>Master judes</h3>

        <p>We have two default master judges both were described in section <a href="#problems">problems</a>:
		      <ul>
		        <li><strong>Generic masterjudge</strong> - it gathers information from test case judges and requires each of them to achieve <em>"accepted"</em> as the result to establish final result as the <em>"accepted"</em>. When any test case ends with error the final answer is inherited from the first failed test case. For example when the problem has five test cases and the second and the fourth ones failed, the final result is inherited from the second test case. Generic masterjudge combines the execution times of all testcases and yields the sum as the final score.
		        <p>It is a proper choice when the problem setter requires that the solution fulfills all his requirements i.e. it is correct and sufficiently efficient.</p>
		        </li>
		        <li><strong>Score is % of correctly solved sets</strong> - it is a more liberal masterjudge which allows to accept incomplete solution with the score which is the percentage of correctly solved test cases. For example when the problem has five test cases and again the second and the fourth ones failed but the rest was passed, the final score is equal to <em>60%</em>. The advantage is that the user gets more information about the correctness level of its solution.
		        <p>It is a proper choice when the problem setter wants to distinguish user's solutions. It is possible to design test cases to be easier or more difficult to pass.</p>

		        	<div class="example-box">
	            	<p>For example consider the problem of power function i.e. for (possibly big) integer numbers <em>a</em> and <em>b</em> calculate the value of <em>a<sup>b</sup></em>. The first test case can deliver only input instances for which the result is in the standard numeric type scope. Another test case can require from the solution to implement the big numbers model. These two test cases give an information on the advancement of the solution. The third test case could also take into account the aspect of the performance and distinguish solutions implementing naive algorithms from the better ones which implement the fast power algorithm.</p>
	            	<p>The least advanced (but in some way correct) solutions will pass the first test case and achieve the result of <em>33%</em> while the more complex solutions (implementing big numbers) are able to pass the first and the second test and achieve the result of <em>66%</em>. To achieve the best result of <em>100%</em> the solution needs to implement both big numbers and fast power algorithms to pass all three test cases.</p>
	            </div>
		        </li>
		      </ul>
        </p>


      <h2 id="advanced-judges">5. Advanced test case judges</h2>

        <p>In the previous section we have discussed default test case judges which are sufficient for most situations. However there are problems which require individual solutions due to nature of the problem. In this section we present examples of the problems along with descriptions of test case judges.</p>

        <p>Test case judge has access to the following information:</p>
        <ul>
        	<li>model input</li>
        	<li>model output</li>
        	<li>user's output</li>
        	<li>user's source code</li>
        </ul>

        <h3>Impossible model output file</h3>

        	<p>Consider following problem task:</p>

        	<div class="example-box">
        			For given function <em>f</em> find its root i.e. the argument <em>x<sub>0</sub></em> that <em>f(x<sub>0</sub>) = 0</em>.
        	</div>

        	<p>In general there are many solutions to the problem, for example for polynomial <em>x<sup>2</sup> + x - 2</em> the numbers <em>1</em> and <em>-2</em> are both correct answers. You can see that it is hard to prepare model output file in test case. There are possibly infinitely many solutions for the certain functions thus it is impossible to keep all of them in the output file. It forces us to use different approach.</p>

        	<div class="example-box">
        			<p><strong>Judge description: </strong> The test case judge should verify the condition from the problem task i.e. for the user's answer from the output file it should check if that answer is a root of the function.</p>
        			<p>Test case judge uses his access to model input file to read the problem instance.</p>
        	</div>


        <h3>Ambiguous model output file</h3>

        	<p>Consider the example:</p>

        	<div class="example-box">
        			For given graph <em>G</em> with <em>n</em> vertices <em>1, 2, ..., n</em> determine if it has hamiltonian cycle (i.e. closed loop through a graph that visits each node exactly once). If the hamiltonian cycle exists print it as a sequence of vertices.
        	</div>

        	<p>It is easy to see that <em>1-2-3-1</em> is the same cycle as <em>2-3-1-2</em>. We could add the requirement to start with the smallest vertex number. Unfortunately it is possible that there exists many different hamiltonian cycles which are not cyclic shifts. We could again use the previous approach and verify if user's answer is really hamiltonian cycle. Alternatively we can build model output file with all possible hamiltonian cycles:</p>

        	<div class="example-box">
        			<p><strong>Judge description: </strong> For user's answer the judge looks for that specific one on the list contained in model output file.</p>
        	</div>

        	<p><strong>Remark</strong> It can be problematic to keep all answers due to possible huge number of good solutions.</p>


      <h2 id="advanced-master-judges">6. Advanced master judges</h2>

        <p>Similarly to test case judges it is possible to create custom master judges. In certain situations the problem setter may want to extend functionality of existing master judge or even implement brand new one. In this section we present examples of the master judges along with a motivation.</p>

        <p>Master judge has access to the following information:</p>
        <ul>
        	<li>results from test case judes</li>
        	<li>user's source code</li>
        </ul>

        <h3>Weighted % of correctly solved sets</h3>

        	<p>Here we present the generalisation of <em>Score is % of correctly solved sets</em> master judge. It was a little disadventage that each test case is worth the same and to increase to influence of some submission's aspect you were forced to produce many test cases.</p>

        	<p>For example when your test cases verify three aspects <em>A,B</em> and <em>C</em> of the problem and you would like to put weights <em>20%</em>, <em>30%</em> and <em>50%</em> respectively, you were able to do that by creating <em>10</em> test cases. Two of them responsible for an aspect <em>A</em>, three of them responsible for an aspect <em>B</em> and five of them responsible for an aspect <em>C</em>. However it is inconvenient and you can consider following idea:</p>

        	<div class="example-box">
        		<p><strong>Master judge description:</strong> Master judge has the information about the number of test cases and weights which it should assign to each test case. The final score is the weighted sum of accepted test cases.</p>
        		<p>For example for three test cases <em>a,b,c</em> and weights <em>20%, 30%, 50%</em> the submission gets one of the possible results depending on passed test cases:
        		<ul>
        			<li><strong>no test case passed</strong> - 0%</li>
        			<li><strong>a</strong> - 20%</li>
        			<li><strong>b</strong> - 30%</li>
        			<li><strong>a,b</strong> - 50%</li>
        			<li><strong>c</strong> - 50%</li>
        			<li><strong>a,c</strong> - 70%</li>
        			<li><strong>b,c</strong> - 80%</li>
        			<li><strong>a,b,c</strong> - 100%</li>
        		</ul>
        		</p>
        	</div>

        <h3>Forbidden structures in source code</h3>

        	<p>The problem setter may require that the solution cannot use some programming structures. For example he may want to allow to use language <em>C++</em> but with no access to STL library to force users to implement efficent data structures manually. Another example is to restrict source codes to not use loop structures to support only solutions based on recursion.</p>

        	<div class="example-box">
        		<p><strong>Master judge description:</strong> Master judge uses access to the user's source code to detect usages of forbidden keywords (for example loops: while, for, goto). When forbidden keyword is detected the final status is set to <em>wrong aswer</em> in other case the master judge performs classical verification (for example the same as Generic masterjudge).</p>
        	</div>


      <h2 id="more-about-statuses">Appendix: Statuses</h2>
      	There are two levels when the status is assigned to the submission:
      	<ul>
      		<li><strong>test case</strong> - the status produced by the test case judge,</li>
      		<li><strong>master judge</strong></li>
      	</ul>

      	<p>The master judge is a high order level component and it can arbitrary assign any status to the submission. We are going to focus on the test case judge statuses.</p>

      	<p>We separate statuses into two groups: semantic and systemic. The semantic statuses are strictly related to the correctness of the answer to the problem. On the other hand, the systemic statuses are syntactic related and the judge gets it from the system.</p>

      	<ul>
      		<li><h4>Semantic statuses</h4>
      			<ul>
		      		<li><strong>Accepted (AC)</strong> - the submission is a correct solution to the problem.</li>
			        <li><strong>Wrong answer (WA)</strong> - the submission is an incorrect solution.</li>		
      			</ul>
      		</li>
      		<li><h4>Sytemic statuses</h4>
						<ul>
							<li><strong>Time limit exceeded (TLE)</strong> - the submission execution took too long.</li>
			        <li><strong>Runtime error (RE)</strong> - the error occurred during program execution.</li>
			        <li><strong>Compilation error (CE)</strong> - the error occurred during compilation or syntax validation in interpreter.</li>
			        <li><strong>Internal error (IE)</strong> - the error occurred on the serivice side. One of the possible reasons can be poorly designed test case judge or master judge.</li>
      			</ul>
      		</li>
      	</ul>

      	<p>The Integral error covers wide area of errors thus in the near future we will introduce another type of error for judge and master judge errors.</p>

      	<p>To ilustrate errors consider again the following example:</p>

      	<div class="example-box">
					<p>For a positive integer <em>n</em> calculate the value of the sum of all positive integers that are not greater than <em>n</em> i.e. <em>1 + 2 + 3 + ... + n</em>. For example when <em>n = 5</em> then the correct answer is <em>15</em>.</p>
          <p>
            <strong>Input:</strong> In the first line there will be the number <em>1 ≤ t ≤ 10000000</em> which is the number of instances for your problem. In each of the next <em>t</em> lines there will be one number <em>n</em> for which you should calculate the described initial sum.
          </p>
          <p>
            <strong>Output:</strong> For each <em>n</em> print the calculated initial sum. Separate answers with new line character.
          </p>
      	</div>

      	<p>The first error which can occur is the <em>compilation error</em>, for example submitting the following source code would produce the CE status:</p>

        <div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #008000; font-weight: bold">return</span> n<span style="color: #666666">*</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t <span style="color: #408080; font-style: italic">// missing semicolon</span>
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
				</div>

		<p>To obtain <em>execution error</em> we can refer to unallocated memory:</p>

		<div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #008000; font-weight: bold">return</span> n<span style="color: #666666">*</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, n); <span style="color: #408080; font-style: italic">// referring to unallocated memory </span>
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
		</div>

		<p>We will <em>exceed time limit</em> with worse algorithm (if test cases are rich enough):</p>

		<div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #408080; font-style: italic">// suboptimal algorithm</span>
<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #B00040">int</span> i;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> sum <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=1</span>; i <span style="color: #666666">&lt;=</span> n; i<span style="color: #666666">++</span>)
  {
    sum <span style="color: #666666">+=</span> i;
  }
  <span style="color: #008000; font-weight: bold">return</span> sum;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
		</div>

		<p>Bad output formatting causes <em>wrong answer</em> status:</p>

		<div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #008000; font-weight: bold">return</span> n<span style="color: #666666">*</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld&quot;</span>, initsum(n)); <span style="color: #408080; font-style: italic">// missing new line character</span>
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
		</div>

		<p>At the end we present correct and optimal solution which passes all test cases and obtains <em>accepted</em> status:</p>

		<div id="judge-source-code" class="problem_sourcecode">
<!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BC7A00">#include &lt;stdio.h&gt;</span>

<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> <span style="color: #0000FF">initsum</span>(<span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n)
{
  <span style="color: #008000; font-weight: bold">return</span> n<span style="color: #666666">*</span>(n<span style="color: #666666">+1</span>)<span style="color: #666666">/2</span>;
}

<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
  <span style="color: #B00040">int</span> t;
  <span style="color: #B00040">long</span> <span style="color: #B00040">long</span> n;
  scanf(<span style="color: #BA2121">&quot;%d&quot;</span>, <span style="color: #666666">&amp;</span>t);
  <span style="color: #008000; font-weight: bold">while</span> (t <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>)
  {
    scanf(<span style="color: #BA2121">&quot;%lld&quot;</span>, <span style="color: #666666">&amp;</span>n);
    printf(<span style="color: #BA2121">&quot;%lld</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&quot;</span>, initsum(n));
    t<span style="color: #666666">--</span>;
  }
  <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}
</pre></div>
		</div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>
  </body>
</html>
